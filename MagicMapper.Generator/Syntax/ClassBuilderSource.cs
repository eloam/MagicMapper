using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace MagicMapper.Generator.Syntax;

public class ClassBuilderSource : ISyntaxBuilder
{
    private readonly string _namespace;
    private readonly string _className;
    private IList<UsingDirectiveSyntax> _usings = [];
    private IList<MethodDeclarationSyntax> _methods = [];
    
    public string Namespace => _namespace;
    public string Name => _className;

    public ClassBuilderSource(string ns, string className)
    {
        _namespace = ns;
        _className = className;
    }

    public void AddMapperMethod(IMethodSymbol methodSymbol)
    {
        // Add using directives for the method parameters
        methodSymbol.Parameters.Select(parameterSymbol => parameterSymbol.Type.ContainingNamespace)
            .ToList()
            .ForEach(TryAddUsingDirective);

        // Add using directive for the method return type
        ParameterSyntax[] parameters = methodSymbol.Parameters.Select(parameterSymbol => SyntaxFactory
                .Parameter(SyntaxFactory.Identifier(parameterSymbol.Name))
                .WithType(SyntaxFactory.ParseTypeName(parameterSymbol.Type.Name)))
            .ToArray();

        // Create the method declaration
        MethodDeclarationSyntax methodDeclaration = SyntaxFactory
            .MethodDeclaration(SyntaxFactory.ParseTypeName(methodSymbol.ReturnType.Name), methodSymbol.Name)
            .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword))
            .AddModifiers(SyntaxFactory.Token(SyntaxKind.PartialKeyword))
            .AddParameterListParameters(parameters)
            .WithBody(SyntaxFactory.Block(new ObjectMapper(methodSymbol).Map()))
            .NormalizeWhitespace();

        _methods.Add(methodDeclaration);
    }

  

    private void TryAddUsingDirective(INamespaceSymbol namespaceSymbol)
    {
        UsingDirectiveSyntax usingDirective = SyntaxFactory.UsingDirective(SyntaxFactory.ParseName(namespaceSymbol.Name))
            .NormalizeWhitespace();
        
        if(_usings.Any(x => x.ToFullString() == usingDirective.ToFullString())) 
            return;

        _usings.Add(usingDirective);
    }

    public string Build()
    {
        CompilationUnitSyntax compilationUnit = SyntaxFactory.CompilationUnit()
            .AddUsings(_usings.ToArray())
            .AddMembers(
                SyntaxFactory.NamespaceDeclaration(SyntaxFactory.ParseName(_namespace))
                    .AddMembers(
                        SyntaxFactory.ClassDeclaration(_className)
                            .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword))
                            .AddModifiers(SyntaxFactory.Token(SyntaxKind.PartialKeyword))
                            .AddMembers(_methods.ToArray()! ?? throw new Exception("No methods found."))
                    )
            )
            .NormalizeWhitespace();

        return $"{SyntaxFactory.Comment("// <auto-generated />")}{SyntaxFactory.CarriageReturnLineFeed}{compilationUnit}";
    }

    public override int GetHashCode()
    {
        return _namespace.GetHashCode() + _className.GetHashCode();
    }
}